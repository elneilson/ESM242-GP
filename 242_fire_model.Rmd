---
title: "Fire Spread Model"
author: "Kaley Dodson, Alison Sells, Larissa Neilson"
date: "11/10/2021"
output: html_document
---

```{r setup, include=FALSE}
knitr::opts_chunk$set(echo = TRUE)
library(tidyverse)
library(sf) # needed for st_sample() function
library(data.table)
```

### Define Variables and Compose Equation

Damage function for each unit i at time t, where G is a growth function (this is what I think we would modify with housing parameter)
s_it+1 = G(s-x) # post treatment fuel stock
s_it # fuel stocks
x_it # amount of fuel removed

Assuming fire acts similarly on all variables:
Di = Di(s_t - x_t) 
	= sum w_ij(s_jt-x_jt) where weight w_ij represents the contribution of unit j’s post-treatment fuel stock, (s_jt−x_jt), to fire damage on unit i. The bigger the weight assigned to unit j, the more important that units fuel stock in determining fire damage on unit i.
*** This may be where we adjust impact of houses on damage in next cell ***

After a fire fuels are:
s_it+1 = G[(s-x)(1-Di)]

We want fire to effect fuel stock and houses (i.e. damage to homes?)
house after fire is some variation of hi,t+1 = hit(1−Di)

---------------------------------------------------------------------------------------

Full Fire Damage Equation in Busby et al. 2013 Table 2 (includes costs; picture of equation also on brainstorming doc):

D^k,q = (l1/100 * w^k(Z^j - M^j + Z^k - M^k)) - g^effect

Where:
k = the state of fuel loading for landowner (parcel) k
j = adjacent property
W^k = spatial weights
Z^k,j = beginning fuel load
M^k,j = fuel treatment
g^effect = government suppression effectiveness (I think this is one of the parameters we can exclude from our model..)
Z^k,j and M^k,j parameters all at time t-1

From Plantinga's email:
The damage function is telling you the damage to structures, fuels, and amenities (see equations 3a-c) **on parcel k given conditions on the neighboring parcel j**. There are costs associated with fuel treatments (M) and suppression (g). Fuel treatments are a 0-1 variable that enters into the damage function in Table 2. Suppression comes in through the g^{effect} variable.

### Model code

#### Make Matrices

```{r}
# Random probability numbers
#set.seed(2021) #for consistency going forward can set different seed for random numbers for each scenario
base_vals <-matrix(runif(9, min = 0, max = 1), ncol = 3)

# make burn matrix
burn_vals = matrix(n = 3, ncol = 3)

```

#### Fire Model 

Manual version - no homes

```{r}
# cell 1,1
burn_vals[1,1] = 1

# cell 1,2
if(burn_vals[1,1] == 1) {
  if (base_vals[1,2] > .62){
  burn_vals[1,2] = 0
  } else {
    burn_vals[1,2] = 1}
} else {
  burn_vals[1,2] = 0
}

# cell 2,1
if(burn_vals[1,1] == 1) {
  if (base_vals[2,1] > .62){
  burn_vals[2,1] = 0
  } else {
    burn_vals[2,1] = 1}
} else {
  burn_vals[2,1] = 0
}

# cell 1,3
if(burn_vals[1,2] == 1) {
  if (base_vals[1,3] > .62){
  burn_vals[1,3] = 0
  } else {
    burn_vals[1,3] = 1}
} else {
  burn_vals[1,3] = 0
}

# cell 3,1
if(burn_vals[2,1] == 1) {
  if (base_vals[3,1] > .62){
  burn_vals[3,1] = 0
  } else {
    burn_vals[3,1] = 1}
} else {
  burn_vals[3,1] = 0
}

# cell 2,2
if(burn_vals[1,2] == 1 | burn_vals[2,1] == 1) {
  if (base_vals[2,2] > .62){
  burn_vals[2,2] = 0
  } else {
    burn_vals[2,2] = 1}
} else {
  burn_vals[2,2] = 0
}

# cell 2,3
if(burn_vals[1,3] == 1 | burn_vals[2,2] == 1) {
  if (base_vals[2,3] > .62){
  burn_vals[2,3] = 0
  } else {
    burn_vals[2,3] = 1}
} else {
  burn_vals[2,3] = 0
}

# cell 3,2
if(burn_vals[3,1] == 1 | burn_vals[2,2] == 1) {
  if (base_vals[3,2] > .62){
  burn_vals[3,2] = 0
  } else {
    burn_vals[3,2] = 1}
} else {
  burn_vals[3,2] = 0
}

# cell 3,3
if(burn_vals[3,2] == 1 | burn_vals[2,3] == 1) {
  if (base_vals[3,3] > .62){
  burn_vals[3,3] = 0
  } else {
    burn_vals[3,3] = 1}
} else {
  burn_vals[3,3] = 0
}
```

```{r}
# no homes iterations
burn_1 <- burn_vals
burn_2 <- burn_vals
burn_3 <- burn_vals
burn_4 <- burn_vals
burn_5 <- burn_vals
burn_6 <- burn_vals
burn_7 <- burn_vals
burn_8 <- burn_vals
burn_9 <- burn_vals
burn_10 <- burn_vals

combined <- cbind(burn_1, burn_2, burn_3, burn_4, burn_5, burn_6, burn_7, burn_8, burn_9, burn_10) %>% 
  as.vector() 

(count <- table(combined))


```

```{r}
# 3 homes iterations
burn_1_h <- burn_vals
burn_2_h <- burn_vals
burn_3_h <- burn_vals
burn_4_h <- burn_vals
burn_5_h <- burn_vals
burn_6_h <- burn_vals
burn_7_h <- burn_vals
burn_8_h <- burn_vals
burn_9_h <- burn_vals
burn_10_h <- burn_vals
burn_11_h <- burn_vals
burn_12_h <- burn_vals
burn_13_h <- burn_vals
burn_14_h <- burn_vals
burn_15_h <- burn_vals

combined_h <- cbind(burn_1_h, burn_2_h, burn_3_h, burn_4_h, burn_5_h, burn_6_h, burn_7_h, burn_8_h, burn_9_h, burn_10_h)

combined_h <- cbind(burn_1_h, burn_2_h, burn_3_h, burn_4_h, burn_5_h, burn_6_h, burn_7_h, burn_8_h, burn_9_h, burn_10_h, burn_11_h, burn_12_h, burn_13_h, burn_14_h, burn_15_h)

(count_h <- table(combined_h))

```

Manual version - 3 homes

```{r}
base_vals <-matrix(runif(9, min = 0, max = 1), ncol = 3)
burn_vals = matrix(n = 3, ncol = 3)

# cell 1,1
burn_vals[1,1] = 1

# cell 1,2
if(burn_vals[1,1] == 1) {
  if (base_vals[1,2] > .62){
  burn_vals[1,2] = 0
  } else {
    burn_vals[1,2] = 1}
} else {
  burn_vals[1,2] = 0
}

# cell 2,1
if(burn_vals[1,1] == 1) {
  if (base_vals[2,1] > .56){
  burn_vals[2,1] = 0
  } else {
    burn_vals[2,1] = 2}
} else {
  burn_vals[2,1] = 0
}

# cell 1,3
if(burn_vals[1,2] == 1) {
  if (base_vals[1,3] > .56){
  burn_vals[1,3] = 0
  } else {
    burn_vals[1,3] = 2}
} else {
  burn_vals[1,3] = 0
}

# cell 3,1
if(burn_vals[2,1] == 1) {
  if (base_vals[3,1] > .62){
  burn_vals[3,1] = 0
  } else {
    burn_vals[3,1] = 1}
} else {
  burn_vals[3,1] = 0
}

# cell 2,2
if(burn_vals[1,2] == 1 | burn_vals[2,1] == 1) {
  if (base_vals[2,2] > .62){
  burn_vals[2,2] = 0
  } else {
    burn_vals[2,2] = 1}
} else {
  burn_vals[2,2] = 0
}

# cell 2,3
if(burn_vals[1,3] == 1 | burn_vals[2,2] == 1) {
  if (base_vals[2,3] > .62){
  burn_vals[2,3] = 0
  } else {
    burn_vals[2,3] = 1}
} else {
  burn_vals[2,3] = 0
}

# cell 3,2
if(burn_vals[3,1] == 1 | burn_vals[2,2] == 1) {
  if (base_vals[3,2] > .56){
  burn_vals[3,2] = 0
  } else {
    burn_vals[3,2] = 2}
} else {
  burn_vals[3,2] = 0
}

# cell 3,3
if(burn_vals[3,2] == 1 | burn_vals[2,3] == 1) {
  if (base_vals[3,3] > .62){
  burn_vals[3,3] = 0
  } else {
    burn_vals[3,3] = 1}
} else {
  burn_vals[3,3] = 0
}

```


Function version of 9x9 manual model w/o homes

```{r}
# if a cell's assigned probability is less than .62, then it burns and is assigned a value of 1 in the burn matrix
# x = burn_vals & y = base_vals

base_vals <-matrix(runif(9, min = 0, max = 1), ncol = 3)
burn_vals = matrix(n = 3, ncol = 3)
burn <- burn_function(burn_vals, base_vals)

burn_function = function(x,y){
  
# cell 1,1
x[1,1] = 1

# cell 1,2
if(x[1,1] == 1) {
  if (y[1,2] > .62){
  x[1,2] = 0
  } else {
    x[1,2] = 1}
} else {
  x[1,2] = 0
}

# cell 2,1
if(x[1,1] == 1) {
  if (y[2,1] > .62){
  x[2,1] = 0
  } else {
    x[2,1] = 1}
} else {
  x[2,1] = 0
}

# cell 1,3
if(x[1,2] == 1) {
  if (y[1,3] > .62){
  x[1,3] = 0
  } else {
    x[1,3] = 1}
} else {
  x[1,3] = 0
}

# cell 3,1
if(x[2,1] == 1) {
  if (y[3,1] > .62){
  x[3,1] = 0
  } else {
    x[3,1] = 1}
} else {
  x[3,1] = 0
}

# cell 2,2
if(x[1,2] == 1 | x[2,1] == 1) {
  if (y[2,2] > .62){
  x[2,2] = 0
  } else {
    x[2,2] = 1}
} else {
  x[2,2] = 0
}

# cell 2,3
if(x[1,3] == 1 | x[2,2] == 1) {
  if (y[2,3] > .62){
  x[2,3] = 0
  } else {
    x[2,3] = 1}
} else {
  x[2,3] = 0
}

# cell 3,2
if(x[3,1] == 1 | x[2,2] == 1) {
  if (y[3,2] > .62){
  x[3,2] = 0
  } else {
    x[3,2] = 1}
} else {
  x[3,2] = 0
}

# cell 3,3
if(x[3,2] == 1 | x[2,3] == 1) {
  if (y[3,3] > .62){
  x[3,3] = 0
  } else {
    x[3,3] = 1}
} else {
  x[3,3] = 0
}
    
  return(x)
}
```

```{r}
# re-coding for larger matrix
burn_vals = matrix(nrow = 10, ncol = 10)
base_vals <-matrix(runif(100, min = 0, max = 1), ncol = 10)

# draft for loop 
for(i in 1:nrow(burn_vals)){
  for(j in 1:ncol(burn_vals)){
    burn_function = function(x,y){
  
# cell 1,1
x[1,1] = 1

# # 1st row cells
# if(x[i,j-1] == 1) {
#   if (y[i,j] > .62){
#   x[i,j] = 0
#   } else {
#     x[i,j] = 1}
# } else {
#   x[i,j] = 0
# }
# 
# # 1st col cells 
# if(x[i-1,j] == 1) {
#   if (y[i,j] > .62){
#   x[i,j] = 0
#   } else {
#     x[i,j] = 1}
# } else {
#   x[i,j] = 0
# }

# remaining cells
if(x[i,j-1] == 1 | x[i-1,j] == 1) {
  if (y[i,j] > .62){
  x[i,j] = 0
  } else {
    x[i,j] = 1}
} else {
  x[i,j] = 0
}
    
  return(x)
}
  }
}
```



```{r}
# if else structure
#if(){
#  
#}else{
#  
#}


# Function of full fire damage equation as is:
# D^k,q = (l1/100 * w^k(Z^j - M^j + Z^k - M^k)) - g^effect (modifying this)

fire_damage <- function(w, Zj, Zk, Mj, Mk, g) {
  Dkq <- ((0.95/100) * (w * (Zj - Mj + Zk - Mk))) - g
  return(Dkq)
}

# Using the function (values taken from paper)
x <- fire_damage(0.5, 3, 3, 0.9581816, 0.5456977, 0.10)
x

# If else statement for the two states
if(x < 0){
print("Not burned")
} else {
print("Burned")
}

#^ Something along these lines..

```

```{r}
# Pick ten random points from inside box and put them in p
set.seed(2021)
p <- st_sample(matrix, size = 9) # select 9 values
# Error says st_sample cannot be used on a matrix

# If else statement to determine fire spread (pull from work code)
 
# Maybe map those using plot? (pull from gis code) 
```


